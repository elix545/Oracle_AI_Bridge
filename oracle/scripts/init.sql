-- Crear usuario middleware
CREATE USER middleware IDENTIFIED BY oracle;

-- Otorgar privilegios necesarios al usuario middleware
GRANT CONNECT, RESOURCE TO middleware;
GRANT CREATE SESSION TO middleware;
GRANT CREATE TABLE TO middleware;
GRANT CREATE SEQUENCE TO middleware;
GRANT CREATE PROCEDURE TO middleware;
GRANT CREATE TRIGGER TO middleware;
GRANT UNLIMITED TABLESPACE TO middleware;
GRANT EXECUTE ON DBMS_LOCK TO middleware;
GRANT CREATE JOB TO middleware;

-- Secuencia para el ID en el esquema middleware (crear antes de la tabla)
CREATE SEQUENCE middleware.PROMPT_QUEUE_SEQ START WITH 1 INCREMENT BY 1;

-- Crear tabla principal en el esquema middleware
CREATE TABLE middleware.PROMPT_QUEUE (
    ID NUMBER PRIMARY KEY,
    USUARIO VARCHAR2(35),
    MODULO VARCHAR2(4),
    TRANSICION VARCHAR2(4),
    PROMPT_REQUEST VARCHAR2(4000),
    PROMPT_RESPONSE CLOB,
    FLAG_LECTURA NUMBER(1) DEFAULT 0,
    FLAG_COMPLETADO NUMBER(1) DEFAULT 0,
    FECHA_REQUEST DATE DEFAULT SYSDATE,
    FECHA_RESPONSE DATE,
    FECHA_LECTURA DATE,
    MODEL VARCHAR2(50) DEFAULT 'llama3:8b'
);

-- Trigger para auto-incrementar el ID
CREATE OR REPLACE TRIGGER middleware.PROMPT_QUEUE_TRG
BEFORE INSERT ON middleware.PROMPT_QUEUE
FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT middleware.PROMPT_QUEUE_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END;
/

-- Constraints
ALTER TABLE middleware.PROMPT_QUEUE ADD CONSTRAINT CHK_FLAG_LECTURA CHECK (FLAG_LECTURA IN (0,1));
ALTER TABLE middleware.PROMPT_QUEUE ADD CONSTRAINT CHK_FLAG_COMPLETADO CHECK (FLAG_COMPLETADO IN (0,1));

-- Función para insertar en el esquema middleware
CREATE OR REPLACE FUNCTION middleware.INSERT_PROMPT_REQUEST(
  P_USUARIO IN VARCHAR2,
  P_MODULO IN VARCHAR2,
  P_TRANSICION IN VARCHAR2,
  P_PROMPT_REQUEST IN VARCHAR2,
  P_MODEL IN VARCHAR2 DEFAULT 'llama3:8b'
) RETURN NUMBER IS
  NEW_ID NUMBER;
BEGIN
  INSERT INTO middleware.PROMPT_QUEUE (ID, USUARIO, MODULO, TRANSICION, PROMPT_REQUEST, MODEL, FLAG_LECTURA, FLAG_COMPLETADO, FECHA_REQUEST)
  VALUES (middleware.PROMPT_QUEUE_SEQ.NEXTVAL, P_USUARIO, P_MODULO, P_TRANSICION, P_PROMPT_REQUEST, P_MODEL, 0, 0, SYSDATE)
  RETURNING ID INTO NEW_ID;
  RETURN NEW_ID;
END;
/

-- Función para leer con timeout y reintentos en el esquema middleware
CREATE OR REPLACE FUNCTION middleware.READ_PROMPT_REQUEST(
  P_TIMEOUT_SECONDS IN NUMBER DEFAULT 10
) RETURN SYS_REFCURSOR IS
  CUR SYS_REFCURSOR;
  V_START_TIME DATE := SYSDATE;
BEGIN
  LOOP
    OPEN CUR FOR
      SELECT * FROM (
        SELECT * FROM middleware.PROMPT_QUEUE
        WHERE FLAG_LECTURA = 0 AND FLAG_COMPLETADO = 0
        ORDER BY FECHA_REQUEST
      ) WHERE ROWNUM = 1;
    EXIT WHEN CUR%FOUND OR (SYSDATE - V_START_TIME) * 86400 > P_TIMEOUT_SECONDS;
    DBMS_LOCK.SLEEP(1);
  END LOOP;
  RETURN CUR;
END;
/

-- Create a function to convert CLOB to VARCHAR2
CREATE OR REPLACE FUNCTION middleware.CLOB_TO_VARCHAR2(p_clob IN CLOB) 
RETURN VARCHAR2 IS
    l_varchar VARCHAR2(4000);
BEGIN
    IF p_clob IS NULL THEN
        RETURN NULL;
    ELSE
        l_varchar := DBMS_LOB.SUBSTR(p_clob, 4000, 1);
        RETURN l_varchar;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RETURN 'Error converting CLOB: ' || SQLERRM;
END;
/

-- Función para leer PROMPT_RESPONSE por ID (para el servicio)
CREATE OR REPLACE FUNCTION middleware.READ_PROMPT_REQUEST_SVC(
  P_ID IN NUMBER
) RETURN SYS_REFCURSOR IS
  CUR SYS_REFCURSOR;
BEGIN
  OPEN CUR FOR
    SELECT DBMS_LOB.SUBSTR(PROMPT_RESPONSE, 4000, 1) AS PROMPT_RESPONSE,
           ID, USUARIO, MODULO, TRANSICION, PROMPT_REQUEST,
           FLAG_LECTURA, FLAG_COMPLETADO, FECHA_REQUEST, FECHA_RESPONSE, FECHA_LECTURA, MODEL
    FROM middleware.PROMPT_QUEUE 
    WHERE ID = P_ID;
  RETURN CUR;
END;
/

-- Función para actualizar PROMPT_RESPONSE por ID (para el servicio)
CREATE OR REPLACE FUNCTION middleware.UPDATE_PROMPT_REQUEST(
  P_ID IN NUMBER,
  P_PROMPT_RESPONSE IN CLOB
) RETURN NUMBER IS
  V_ROWS_AFFECTED NUMBER;
BEGIN
  UPDATE middleware.PROMPT_QUEUE 
  SET PROMPT_RESPONSE = P_PROMPT_RESPONSE, 
      FECHA_RESPONSE = SYSDATE, 
      FLAG_COMPLETADO = 1 
  WHERE ID = P_ID;
  
  V_ROWS_AFFECTED := SQL%ROWCOUNT;
  RETURN V_ROWS_AFFECTED;
END;
/

-- Función para verificar si hay datos en la cola (para el servicio)
CREATE OR REPLACE FUNCTION middleware.HAS_DATA_PROMPT_QUEUE
RETURN NUMBER IS
  V_COUNT NUMBER;
BEGIN
  SELECT COUNT(*) INTO V_COUNT FROM middleware.PROMPT_QUEUE;
  RETURN V_COUNT;
END;
/

-- Función para consultar PROMPT_QUEUE con paginación y filtros
CREATE OR REPLACE FUNCTION middleware.QUERY_PROMPT_QUEUE(
  P_OFFSET IN NUMBER DEFAULT 0,
  P_LIMIT IN NUMBER DEFAULT 10,
  P_USUARIO IN VARCHAR2 DEFAULT NULL,
  P_MODULO IN VARCHAR2 DEFAULT NULL,
  P_TRANSICION IN VARCHAR2 DEFAULT NULL,
  P_FLAG_LECTURA IN NUMBER DEFAULT NULL,
  P_FLAG_COMPLETADO IN NUMBER DEFAULT NULL,
  P_MODEL IN VARCHAR2 DEFAULT NULL,
  P_FECHA_DESDE IN DATE DEFAULT NULL,
  P_FECHA_HASTA IN DATE DEFAULT NULL
) RETURN SYS_REFCURSOR IS
  CUR SYS_REFCURSOR;
BEGIN
  -- Consulta simple sin filtros para evitar problemas con SQL dinámico
  OPEN CUR FOR
    SELECT * FROM (
      SELECT a.*, ROWNUM rnum FROM (
        SELECT ID, USUARIO, MODULO, TRANSICION, PROMPT_REQUEST, 
               DBMS_LOB.SUBSTR(PROMPT_RESPONSE, 4000, 1) AS PROMPT_RESPONSE,
               FLAG_LECTURA, FLAG_COMPLETADO, FECHA_REQUEST, FECHA_RESPONSE, FECHA_LECTURA, MODEL
        FROM middleware.PROMPT_QUEUE 
        ORDER BY FECHA_REQUEST DESC
      ) a WHERE ROWNUM <= :p_max_row
    ) WHERE rnum > :p_offset;
  
  RETURN CUR;
END;
/

-- Job de limpieza mensual (solo si DBMS_SCHEDULER está disponible)
BEGIN
  DBMS_SCHEDULER.CREATE_JOB (
    job_name        => 'PROMPT_QUEUE_CLEANUP',
    job_type        => 'PLSQL_BLOCK',
    job_action      => 'BEGIN DELETE FROM middleware.PROMPT_QUEUE WHERE FECHA_REQUEST < SYSDATE - 30; END;',
    start_date      => TRUNC(ADD_MONTHS(SYSDATE, 1), 'MM'),
    repeat_interval => 'FREQ=MONTHLY;BYMONTHDAY=1',
    enabled         => TRUE
  );
EXCEPTION
  WHEN OTHERS THEN
    NULL; -- Ignorar errores si DBMS_SCHEDULER no está disponible
END;
/ 